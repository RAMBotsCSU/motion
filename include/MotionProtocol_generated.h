// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MOTIONPROTOCOL_MOTIONPROTOCOL_H_
#define FLATBUFFERS_GENERATED_MOTIONPROTOCOL_MOTIONPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace MotionProtocol {

struct Remote;
struct RemoteBuilder;

struct Message;
struct MessageBuilder;

struct ODriveStatus;
struct ODriveStatusBuilder;

enum MessageType : int8_t {
  MessageType_UNKNOWN = 0,
  MessageType_REMOTE = 1,
  MessageType_MIN = MessageType_UNKNOWN,
  MessageType_MAX = MessageType_REMOTE
};

inline const MessageType (&EnumValuesMessageType())[2] {
  static const MessageType values[] = {
    MessageType_UNKNOWN,
    MessageType_REMOTE
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[3] = {
    "UNKNOWN",
    "REMOTE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType_UNKNOWN, MessageType_REMOTE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

struct Remote FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RemoteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_MODE = 6,
    VT_RLR = 8,
    VT_RFB = 10,
    VT_RT = 12,
    VT_LLR = 14,
    VT_LFB = 16,
    VT_LT = 18,
    VT_DPAD_U = 20,
    VT_DPAD_D = 22,
    VT_DPAD_L = 24,
    VT_DPAD_R = 26,
    VT_TRIANGLE = 28,
    VT_CROSS = 30,
    VT_SQUARE = 32,
    VT_CIRCLE = 34
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  int8_t mode() const {
    return GetField<int8_t>(VT_MODE, 0);
  }
  int8_t rlr() const {
    return GetField<int8_t>(VT_RLR, 0);
  }
  int8_t rfb() const {
    return GetField<int8_t>(VT_RFB, 0);
  }
  uint8_t rt() const {
    return GetField<uint8_t>(VT_RT, 0);
  }
  int8_t llr() const {
    return GetField<int8_t>(VT_LLR, 0);
  }
  int8_t lfb() const {
    return GetField<int8_t>(VT_LFB, 0);
  }
  uint8_t lt() const {
    return GetField<uint8_t>(VT_LT, 0);
  }
  bool dpad_u() const {
    return GetField<uint8_t>(VT_DPAD_U, 0) != 0;
  }
  bool dpad_d() const {
    return GetField<uint8_t>(VT_DPAD_D, 0) != 0;
  }
  bool dpad_l() const {
    return GetField<uint8_t>(VT_DPAD_L, 0) != 0;
  }
  bool dpad_r() const {
    return GetField<uint8_t>(VT_DPAD_R, 0) != 0;
  }
  bool triangle() const {
    return GetField<uint8_t>(VT_TRIANGLE, 0) != 0;
  }
  bool cross() const {
    return GetField<uint8_t>(VT_CROSS, 0) != 0;
  }
  bool square() const {
    return GetField<uint8_t>(VT_SQUARE, 0) != 0;
  }
  bool circle() const {
    return GetField<uint8_t>(VT_CIRCLE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           VerifyField<int8_t>(verifier, VT_RLR, 1) &&
           VerifyField<int8_t>(verifier, VT_RFB, 1) &&
           VerifyField<uint8_t>(verifier, VT_RT, 1) &&
           VerifyField<int8_t>(verifier, VT_LLR, 1) &&
           VerifyField<int8_t>(verifier, VT_LFB, 1) &&
           VerifyField<uint8_t>(verifier, VT_LT, 1) &&
           VerifyField<uint8_t>(verifier, VT_DPAD_U, 1) &&
           VerifyField<uint8_t>(verifier, VT_DPAD_D, 1) &&
           VerifyField<uint8_t>(verifier, VT_DPAD_L, 1) &&
           VerifyField<uint8_t>(verifier, VT_DPAD_R, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRIANGLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CROSS, 1) &&
           VerifyField<uint8_t>(verifier, VT_SQUARE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CIRCLE, 1) &&
           verifier.EndTable();
  }
};

struct RemoteBuilder {
  typedef Remote Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(Remote::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_mode(int8_t mode) {
    fbb_.AddElement<int8_t>(Remote::VT_MODE, mode, 0);
  }
  void add_rlr(int8_t rlr) {
    fbb_.AddElement<int8_t>(Remote::VT_RLR, rlr, 0);
  }
  void add_rfb(int8_t rfb) {
    fbb_.AddElement<int8_t>(Remote::VT_RFB, rfb, 0);
  }
  void add_rt(uint8_t rt) {
    fbb_.AddElement<uint8_t>(Remote::VT_RT, rt, 0);
  }
  void add_llr(int8_t llr) {
    fbb_.AddElement<int8_t>(Remote::VT_LLR, llr, 0);
  }
  void add_lfb(int8_t lfb) {
    fbb_.AddElement<int8_t>(Remote::VT_LFB, lfb, 0);
  }
  void add_lt(uint8_t lt) {
    fbb_.AddElement<uint8_t>(Remote::VT_LT, lt, 0);
  }
  void add_dpad_u(bool dpad_u) {
    fbb_.AddElement<uint8_t>(Remote::VT_DPAD_U, static_cast<uint8_t>(dpad_u), 0);
  }
  void add_dpad_d(bool dpad_d) {
    fbb_.AddElement<uint8_t>(Remote::VT_DPAD_D, static_cast<uint8_t>(dpad_d), 0);
  }
  void add_dpad_l(bool dpad_l) {
    fbb_.AddElement<uint8_t>(Remote::VT_DPAD_L, static_cast<uint8_t>(dpad_l), 0);
  }
  void add_dpad_r(bool dpad_r) {
    fbb_.AddElement<uint8_t>(Remote::VT_DPAD_R, static_cast<uint8_t>(dpad_r), 0);
  }
  void add_triangle(bool triangle) {
    fbb_.AddElement<uint8_t>(Remote::VT_TRIANGLE, static_cast<uint8_t>(triangle), 0);
  }
  void add_cross(bool cross) {
    fbb_.AddElement<uint8_t>(Remote::VT_CROSS, static_cast<uint8_t>(cross), 0);
  }
  void add_square(bool square) {
    fbb_.AddElement<uint8_t>(Remote::VT_SQUARE, static_cast<uint8_t>(square), 0);
  }
  void add_circle(bool circle) {
    fbb_.AddElement<uint8_t>(Remote::VT_CIRCLE, static_cast<uint8_t>(circle), 0);
  }
  explicit RemoteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Remote> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Remote>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Remote> CreateRemote(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    int8_t mode = 0,
    int8_t rlr = 0,
    int8_t rfb = 0,
    uint8_t rt = 0,
    int8_t llr = 0,
    int8_t lfb = 0,
    uint8_t lt = 0,
    bool dpad_u = false,
    bool dpad_d = false,
    bool dpad_l = false,
    bool dpad_r = false,
    bool triangle = false,
    bool cross = false,
    bool square = false,
    bool circle = false) {
  RemoteBuilder builder_(_fbb);
  builder_.add_circle(circle);
  builder_.add_square(square);
  builder_.add_cross(cross);
  builder_.add_triangle(triangle);
  builder_.add_dpad_r(dpad_r);
  builder_.add_dpad_l(dpad_l);
  builder_.add_dpad_d(dpad_d);
  builder_.add_dpad_u(dpad_u);
  builder_.add_lt(lt);
  builder_.add_lfb(lfb);
  builder_.add_llr(llr);
  builder_.add_rt(rt);
  builder_.add_rfb(rfb);
  builder_.add_rlr(rlr);
  builder_.add_mode(mode);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_REMOTE = 6
  };
  MotionProtocol::MessageType type() const {
    return static_cast<MotionProtocol::MessageType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const MotionProtocol::Remote *remote() const {
    return GetPointer<const MotionProtocol::Remote *>(VT_REMOTE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_REMOTE) &&
           verifier.VerifyTable(remote()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(MotionProtocol::MessageType type) {
    fbb_.AddElement<int8_t>(Message::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_remote(::flatbuffers::Offset<MotionProtocol::Remote> remote) {
    fbb_.AddOffset(Message::VT_REMOTE, remote);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MotionProtocol::MessageType type = MotionProtocol::MessageType_UNKNOWN,
    ::flatbuffers::Offset<MotionProtocol::Remote> remote = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_remote(remote);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ODriveStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ODriveStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONNECTED0 = 4,
    VT_CONNECTED1 = 6,
    VT_CONNECTED2 = 8,
    VT_CONNECTED3 = 10,
    VT_CONNECTED4 = 12,
    VT_CONNECTED5 = 14,
    VT_ERROR00 = 16,
    VT_ERROR01 = 18,
    VT_ERROR10 = 20,
    VT_ERROR11 = 22,
    VT_ERROR20 = 24,
    VT_ERROR21 = 26,
    VT_ERROR30 = 28,
    VT_ERROR31 = 30,
    VT_ERROR40 = 32,
    VT_ERROR41 = 34,
    VT_ERROR50 = 36,
    VT_ERROR51 = 38
  };
  bool connected0() const {
    return GetField<uint8_t>(VT_CONNECTED0, 0) != 0;
  }
  bool connected1() const {
    return GetField<uint8_t>(VT_CONNECTED1, 0) != 0;
  }
  bool connected2() const {
    return GetField<uint8_t>(VT_CONNECTED2, 0) != 0;
  }
  bool connected3() const {
    return GetField<uint8_t>(VT_CONNECTED3, 0) != 0;
  }
  bool connected4() const {
    return GetField<uint8_t>(VT_CONNECTED4, 0) != 0;
  }
  bool connected5() const {
    return GetField<uint8_t>(VT_CONNECTED5, 0) != 0;
  }
  int32_t error00() const {
    return GetField<int32_t>(VT_ERROR00, 0);
  }
  int32_t error01() const {
    return GetField<int32_t>(VT_ERROR01, 0);
  }
  int32_t error10() const {
    return GetField<int32_t>(VT_ERROR10, 0);
  }
  int32_t error11() const {
    return GetField<int32_t>(VT_ERROR11, 0);
  }
  int32_t error20() const {
    return GetField<int32_t>(VT_ERROR20, 0);
  }
  int32_t error21() const {
    return GetField<int32_t>(VT_ERROR21, 0);
  }
  int32_t error30() const {
    return GetField<int32_t>(VT_ERROR30, 0);
  }
  int32_t error31() const {
    return GetField<int32_t>(VT_ERROR31, 0);
  }
  int32_t error40() const {
    return GetField<int32_t>(VT_ERROR40, 0);
  }
  int32_t error41() const {
    return GetField<int32_t>(VT_ERROR41, 0);
  }
  int32_t error50() const {
    return GetField<int32_t>(VT_ERROR50, 0);
  }
  int32_t error51() const {
    return GetField<int32_t>(VT_ERROR51, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTED0, 1) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTED1, 1) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTED2, 1) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTED3, 1) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTED4, 1) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTED5, 1) &&
           VerifyField<int32_t>(verifier, VT_ERROR00, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR01, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR10, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR11, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR20, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR21, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR30, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR31, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR40, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR41, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR50, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR51, 4) &&
           verifier.EndTable();
  }
};

struct ODriveStatusBuilder {
  typedef ODriveStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_connected0(bool connected0) {
    fbb_.AddElement<uint8_t>(ODriveStatus::VT_CONNECTED0, static_cast<uint8_t>(connected0), 0);
  }
  void add_connected1(bool connected1) {
    fbb_.AddElement<uint8_t>(ODriveStatus::VT_CONNECTED1, static_cast<uint8_t>(connected1), 0);
  }
  void add_connected2(bool connected2) {
    fbb_.AddElement<uint8_t>(ODriveStatus::VT_CONNECTED2, static_cast<uint8_t>(connected2), 0);
  }
  void add_connected3(bool connected3) {
    fbb_.AddElement<uint8_t>(ODriveStatus::VT_CONNECTED3, static_cast<uint8_t>(connected3), 0);
  }
  void add_connected4(bool connected4) {
    fbb_.AddElement<uint8_t>(ODriveStatus::VT_CONNECTED4, static_cast<uint8_t>(connected4), 0);
  }
  void add_connected5(bool connected5) {
    fbb_.AddElement<uint8_t>(ODriveStatus::VT_CONNECTED5, static_cast<uint8_t>(connected5), 0);
  }
  void add_error00(int32_t error00) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR00, error00, 0);
  }
  void add_error01(int32_t error01) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR01, error01, 0);
  }
  void add_error10(int32_t error10) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR10, error10, 0);
  }
  void add_error11(int32_t error11) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR11, error11, 0);
  }
  void add_error20(int32_t error20) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR20, error20, 0);
  }
  void add_error21(int32_t error21) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR21, error21, 0);
  }
  void add_error30(int32_t error30) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR30, error30, 0);
  }
  void add_error31(int32_t error31) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR31, error31, 0);
  }
  void add_error40(int32_t error40) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR40, error40, 0);
  }
  void add_error41(int32_t error41) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR41, error41, 0);
  }
  void add_error50(int32_t error50) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR50, error50, 0);
  }
  void add_error51(int32_t error51) {
    fbb_.AddElement<int32_t>(ODriveStatus::VT_ERROR51, error51, 0);
  }
  explicit ODriveStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ODriveStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ODriveStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ODriveStatus> CreateODriveStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool connected0 = false,
    bool connected1 = false,
    bool connected2 = false,
    bool connected3 = false,
    bool connected4 = false,
    bool connected5 = false,
    int32_t error00 = 0,
    int32_t error01 = 0,
    int32_t error10 = 0,
    int32_t error11 = 0,
    int32_t error20 = 0,
    int32_t error21 = 0,
    int32_t error30 = 0,
    int32_t error31 = 0,
    int32_t error40 = 0,
    int32_t error41 = 0,
    int32_t error50 = 0,
    int32_t error51 = 0) {
  ODriveStatusBuilder builder_(_fbb);
  builder_.add_error51(error51);
  builder_.add_error50(error50);
  builder_.add_error41(error41);
  builder_.add_error40(error40);
  builder_.add_error31(error31);
  builder_.add_error30(error30);
  builder_.add_error21(error21);
  builder_.add_error20(error20);
  builder_.add_error11(error11);
  builder_.add_error10(error10);
  builder_.add_error01(error01);
  builder_.add_error00(error00);
  builder_.add_connected5(connected5);
  builder_.add_connected4(connected4);
  builder_.add_connected3(connected3);
  builder_.add_connected2(connected2);
  builder_.add_connected1(connected1);
  builder_.add_connected0(connected0);
  return builder_.Finish();
}

inline const MotionProtocol::Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<MotionProtocol::Message>(buf);
}

inline const MotionProtocol::Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MotionProtocol::Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MotionProtocol::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MotionProtocol::Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MotionProtocol::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MotionProtocol::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MotionProtocol

#endif  // FLATBUFFERS_GENERATED_MOTIONPROTOCOL_MOTIONPROTOCOL_H_
