// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MOTIONPROTOCOL_MOTIONPROTOCOL_H_
#define FLATBUFFERS_GENERATED_MOTIONPROTOCOL_MOTIONPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace MotionProtocol {

struct Remote;
struct RemoteBuilder;

struct Message;
struct MessageBuilder;

enum MessageType : int8_t {
  MessageType_UNKNOWN = 0,
  MessageType_REMOTE = 1,
  MessageType_MIN = MessageType_UNKNOWN,
  MessageType_MAX = MessageType_REMOTE
};

inline const MessageType (&EnumValuesMessageType())[2] {
  static const MessageType values[] = {
    MessageType_UNKNOWN,
    MessageType_REMOTE
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[3] = {
    "UNKNOWN",
    "REMOTE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType_UNKNOWN, MessageType_REMOTE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

struct Remote FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RemoteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_MODE = 6,
    VT_RLR = 8,
    VT_RFB = 10,
    VT_RT = 12,
    VT_LLR = 14,
    VT_LFB = 16,
    VT_LT = 18,
    VT_DPAD_U = 20,
    VT_DPAD_D = 22,
    VT_DPAD_L = 24,
    VT_DPAD_R = 26,
    VT_TRIANGLE = 28,
    VT_CROSS = 30,
    VT_SQUARE = 32,
    VT_CIRCLE = 34
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  int8_t mode() const {
    return GetField<int8_t>(VT_MODE, 0);
  }
  int8_t rlr() const {
    return GetField<int8_t>(VT_RLR, 0);
  }
  int8_t rfb() const {
    return GetField<int8_t>(VT_RFB, 0);
  }
  uint8_t rt() const {
    return GetField<uint8_t>(VT_RT, 0);
  }
  int8_t llr() const {
    return GetField<int8_t>(VT_LLR, 0);
  }
  int8_t lfb() const {
    return GetField<int8_t>(VT_LFB, 0);
  }
  uint8_t lt() const {
    return GetField<uint8_t>(VT_LT, 0);
  }
  bool dpad_u() const {
    return GetField<uint8_t>(VT_DPAD_U, 0) != 0;
  }
  bool dpad_d() const {
    return GetField<uint8_t>(VT_DPAD_D, 0) != 0;
  }
  bool dpad_l() const {
    return GetField<uint8_t>(VT_DPAD_L, 0) != 0;
  }
  bool dpad_r() const {
    return GetField<uint8_t>(VT_DPAD_R, 0) != 0;
  }
  bool triangle() const {
    return GetField<uint8_t>(VT_TRIANGLE, 0) != 0;
  }
  bool cross() const {
    return GetField<uint8_t>(VT_CROSS, 0) != 0;
  }
  bool square() const {
    return GetField<uint8_t>(VT_SQUARE, 0) != 0;
  }
  bool circle() const {
    return GetField<uint8_t>(VT_CIRCLE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           VerifyField<int8_t>(verifier, VT_RLR, 1) &&
           VerifyField<int8_t>(verifier, VT_RFB, 1) &&
           VerifyField<uint8_t>(verifier, VT_RT, 1) &&
           VerifyField<int8_t>(verifier, VT_LLR, 1) &&
           VerifyField<int8_t>(verifier, VT_LFB, 1) &&
           VerifyField<uint8_t>(verifier, VT_LT, 1) &&
           VerifyField<uint8_t>(verifier, VT_DPAD_U, 1) &&
           VerifyField<uint8_t>(verifier, VT_DPAD_D, 1) &&
           VerifyField<uint8_t>(verifier, VT_DPAD_L, 1) &&
           VerifyField<uint8_t>(verifier, VT_DPAD_R, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRIANGLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CROSS, 1) &&
           VerifyField<uint8_t>(verifier, VT_SQUARE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CIRCLE, 1) &&
           verifier.EndTable();
  }
};

struct RemoteBuilder {
  typedef Remote Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(Remote::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_mode(int8_t mode) {
    fbb_.AddElement<int8_t>(Remote::VT_MODE, mode, 0);
  }
  void add_rlr(int8_t rlr) {
    fbb_.AddElement<int8_t>(Remote::VT_RLR, rlr, 0);
  }
  void add_rfb(int8_t rfb) {
    fbb_.AddElement<int8_t>(Remote::VT_RFB, rfb, 0);
  }
  void add_rt(uint8_t rt) {
    fbb_.AddElement<uint8_t>(Remote::VT_RT, rt, 0);
  }
  void add_llr(int8_t llr) {
    fbb_.AddElement<int8_t>(Remote::VT_LLR, llr, 0);
  }
  void add_lfb(int8_t lfb) {
    fbb_.AddElement<int8_t>(Remote::VT_LFB, lfb, 0);
  }
  void add_lt(uint8_t lt) {
    fbb_.AddElement<uint8_t>(Remote::VT_LT, lt, 0);
  }
  void add_dpad_u(bool dpad_u) {
    fbb_.AddElement<uint8_t>(Remote::VT_DPAD_U, static_cast<uint8_t>(dpad_u), 0);
  }
  void add_dpad_d(bool dpad_d) {
    fbb_.AddElement<uint8_t>(Remote::VT_DPAD_D, static_cast<uint8_t>(dpad_d), 0);
  }
  void add_dpad_l(bool dpad_l) {
    fbb_.AddElement<uint8_t>(Remote::VT_DPAD_L, static_cast<uint8_t>(dpad_l), 0);
  }
  void add_dpad_r(bool dpad_r) {
    fbb_.AddElement<uint8_t>(Remote::VT_DPAD_R, static_cast<uint8_t>(dpad_r), 0);
  }
  void add_triangle(bool triangle) {
    fbb_.AddElement<uint8_t>(Remote::VT_TRIANGLE, static_cast<uint8_t>(triangle), 0);
  }
  void add_cross(bool cross) {
    fbb_.AddElement<uint8_t>(Remote::VT_CROSS, static_cast<uint8_t>(cross), 0);
  }
  void add_square(bool square) {
    fbb_.AddElement<uint8_t>(Remote::VT_SQUARE, static_cast<uint8_t>(square), 0);
  }
  void add_circle(bool circle) {
    fbb_.AddElement<uint8_t>(Remote::VT_CIRCLE, static_cast<uint8_t>(circle), 0);
  }
  explicit RemoteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Remote> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Remote>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Remote> CreateRemote(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    int8_t mode = 0,
    int8_t rlr = 0,
    int8_t rfb = 0,
    uint8_t rt = 0,
    int8_t llr = 0,
    int8_t lfb = 0,
    uint8_t lt = 0,
    bool dpad_u = false,
    bool dpad_d = false,
    bool dpad_l = false,
    bool dpad_r = false,
    bool triangle = false,
    bool cross = false,
    bool square = false,
    bool circle = false) {
  RemoteBuilder builder_(_fbb);
  builder_.add_circle(circle);
  builder_.add_square(square);
  builder_.add_cross(cross);
  builder_.add_triangle(triangle);
  builder_.add_dpad_r(dpad_r);
  builder_.add_dpad_l(dpad_l);
  builder_.add_dpad_d(dpad_d);
  builder_.add_dpad_u(dpad_u);
  builder_.add_lt(lt);
  builder_.add_lfb(lfb);
  builder_.add_llr(llr);
  builder_.add_rt(rt);
  builder_.add_rfb(rfb);
  builder_.add_rlr(rlr);
  builder_.add_mode(mode);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_REMOTE = 6
  };
  MotionProtocol::MessageType type() const {
    return static_cast<MotionProtocol::MessageType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const MotionProtocol::Remote *remote() const {
    return GetPointer<const MotionProtocol::Remote *>(VT_REMOTE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_REMOTE) &&
           verifier.VerifyTable(remote()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(MotionProtocol::MessageType type) {
    fbb_.AddElement<int8_t>(Message::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_remote(::flatbuffers::Offset<MotionProtocol::Remote> remote) {
    fbb_.AddOffset(Message::VT_REMOTE, remote);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MotionProtocol::MessageType type = MotionProtocol::MessageType_UNKNOWN,
    ::flatbuffers::Offset<MotionProtocol::Remote> remote = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_remote(remote);
  builder_.add_type(type);
  return builder_.Finish();
}

inline const MotionProtocol::Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<MotionProtocol::Message>(buf);
}

inline const MotionProtocol::Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MotionProtocol::Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MotionProtocol::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MotionProtocol::Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MotionProtocol::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MotionProtocol::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MotionProtocol

#endif  // FLATBUFFERS_GENERATED_MOTIONPROTOCOL_MOTIONPROTOCOL_H_
